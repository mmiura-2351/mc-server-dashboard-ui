import { describe, test, expect, beforeEach, vi } from "vitest";
import {
  getServerPropertiesFile,
  parseServerProperties,
  stringifyServerProperties,
  getServerProperties,
  updateServerProperties,
} from "./server";
import { ok, err } from "neverthrow";

// Mock the API functions
vi.mock("@/services/api", () => ({
  fetchJson: vi.fn(),
  fetchEmpty: vi.fn(),
  fetchWithErrorHandlingInternal: vi.fn(),
}));

import { fetchJson, fetchEmpty } from "@/services/api";

describe("server properties service", () => {
  beforeEach(() => {
    vi.resetAllMocks();
  });

  describe("getServerPropertiesFile", () => {
    test("should return file content on successful API call", async () => {
      const mockResponse = {
        content: "server-port=25565\nmax-players=20\ndifficulty=normal",
        encoding: "utf-8",
        file_info: {},
      };

      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        ok(mockResponse)
      );

      const result = await getServerPropertiesFile(1);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toBe(mockResponse.content);
      }
    });

    test("should return error on API failure", async () => {
      const errorResponse = {
        message: "Not Found",
        status: 404,
      };

      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        err(errorResponse)
      );

      const result = await getServerPropertiesFile(1);

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.status).toBe(404);
      }
    });
  });

  describe("parseServerProperties", () => {
    test("should parse simple properties correctly", () => {
      const content = `server-port=25565
max-players=20
difficulty=normal
pvp=true
hardcore=false`;

      const result = parseServerProperties(content);

      expect(result).toEqual({
        "server-port": 25565,
        "max-players": 20,
        difficulty: "normal",
        pvp: true,
        hardcore: false,
      });
    });

    test("should skip comments and empty lines", () => {
      const content = `#Minecraft server properties
#Generated by server

server-port=25565

# This is a comment
max-players=20`;

      const result = parseServerProperties(content);

      expect(result).toEqual({
        "server-port": 25565,
        "max-players": 20,
      });
    });

    test("should handle mixed value types", () => {
      const content = `string-value=hello world
number-value=123
boolean-true=true
boolean-false=false
empty-value=`;

      const result = parseServerProperties(content);

      expect(result).toEqual({
        "string-value": "hello world",
        "number-value": 123,
        "boolean-true": true,
        "boolean-false": false,
        "empty-value": "",
      });
    });

    test("should handle properties with equals signs in values", () => {
      const content = `motd=Welcome to My Server = Best Server Ever
resource-pack=https://example.com/pack.zip?param=value`;

      const result = parseServerProperties(content);

      expect(result).toEqual({
        motd: "Welcome to My Server = Best Server Ever",
        "resource-pack": "https://example.com/pack.zip?param=value",
      });
    });
  });

  describe("stringifyServerProperties", () => {
    test("should convert properties object back to file format", () => {
      const properties = {
        "server-port": 25565,
        "max-players": 20,
        difficulty: "normal",
        pvp: true,
        hardcore: false,
      };

      const result = stringifyServerProperties(properties);

      // Check that it starts with comment header
      expect(result).toMatch(/^#Minecraft server properties/);
      expect(result).toMatch(/^#Minecraft server properties\n#/);

      // Check that properties are included and sorted
      expect(result).toContain("difficulty=normal");
      expect(result).toContain("hardcore=false");
      expect(result).toContain("max-players=20");
      expect(result).toContain("pvp=true");
      expect(result).toContain("server-port=25565");

      // Check alphabetical order (difficulty should come before hardcore)
      const difficultyIndex = result.indexOf("difficulty=");
      const hardcoreIndex = result.indexOf("hardcore=");
      expect(difficultyIndex).toBeLessThan(hardcoreIndex);
    });

    test("should handle empty properties object", () => {
      const properties = {};
      const result = stringifyServerProperties(properties);

      expect(result).toMatch(/^#Minecraft server properties/);
      // Should only contain header comments
      const lines = result.split("\n");
      expect(lines.length).toBe(2); // Two comment lines
    });
  });

  describe("getServerProperties", () => {
    test("should return parsed properties on successful file read", async () => {
      const mockFileContent =
        "server-port=25565\nmax-players=20\ndifficulty=normal";
      const mockResponse = {
        content: mockFileContent,
        encoding: "utf-8",
        file_info: {},
      };

      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        ok(mockResponse)
      );

      const result = await getServerProperties(1);

      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value).toEqual({
          "server-port": 25565,
          "max-players": 20,
          difficulty: "normal",
        });
      }
    });

    test("should return error if file read fails", async () => {
      const errorResponse = {
        message: "Not Found",
        status: 404,
      };

      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        err(errorResponse)
      );

      const result = await getServerProperties(1);

      expect(result.isErr()).toBe(true);
    });
  });

  describe("updateServerProperties", () => {
    test("should merge new properties with existing ones and save", async () => {
      // Mock the read operation
      const existingContent =
        "server-port=25565\nmax-players=20\ndifficulty=normal";
      const readResponse = {
        content: existingContent,
        encoding: "utf-8",
        file_info: {},
      };

      // Mock successful read and write operations
      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        ok(readResponse)
      );
      (fetchEmpty as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        ok(undefined)
      );

      const newProperties = {
        "max-players": 50,
        pvp: false,
      };

      const result = await updateServerProperties(1, newProperties);

      expect(result.isOk()).toBe(true);

      // Verify both functions were called
      expect(fetchJson).toHaveBeenCalledTimes(1);
      expect(fetchEmpty).toHaveBeenCalledTimes(1);
    });

    test("should return error if read operation fails", async () => {
      const errorResponse = {
        message: "Not Found",
        status: 404,
      };

      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        err(errorResponse)
      );

      const result = await updateServerProperties(1, { "max-players": 50 });

      expect(result.isErr()).toBe(true);
      // Should not attempt write operation
      expect(fetchJson).toHaveBeenCalledTimes(1);
      expect(fetchEmpty).toHaveBeenCalledTimes(0);
    });

    test("should return error if write operation fails", async () => {
      // Mock successful read
      const readResponse = {
        content: "server-port=25565",
        encoding: "utf-8",
        file_info: {},
      };

      // Mock failed write
      const writeError = {
        message: "Internal Server Error",
        status: 500,
      };

      (fetchJson as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        ok(readResponse)
      );
      (fetchEmpty as ReturnType<typeof vi.fn>).mockResolvedValueOnce(
        err(writeError)
      );

      const result = await updateServerProperties(1, { "max-players": 50 });

      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.status).toBe(500);
      }
    });
  });
});
